// SPDX-License-Identifier: MIT

pragma solidity 0.8.19;
import {DecentralizedStableCoin} from "../../src/DecentralizedStableCoin.sol";
import {DSCEngine} from "../../src/DSCEngine.sol";
import {VulnDeployDecentralizedStableCoin} from "../../script/VulnDeployDecentralizedStableCoin.s.sol";
import {VulnHelperConfig} from "../../script/VulnHelperConfig.sol";
import {ERC20DecimalsMock} from "@openzeppelin/contracts/mocks/ERC20DecimalsMock.sol";
import {MockV3Aggregator} from "../mocks/MockV3Aggregator.sol";
import {Test, console} from "forge-std/Test.sol";
import {StdCheats} from "forge-std/StdCheats.sol";

contract TestTokenDecimalExploitOld is StdCheats, Test {
    DSCEngine public dsce;
    DecentralizedStableCoin public dsc;
    VulnDeployDecentralizedStableCoin deployer;
    VulnHelperConfig public helperConfig;

    address public ethUsdPriceFeed;
    address public btcUsdPriceFeed;
    address public weth;
    address public wbtc;
    uint256 public wethDecimals;
    uint256 public wbtcDecimals;
    uint256 public feedDecimals;
    uint256 public deployerKey;

    address public user = address(1);
    address public exploiter = address(2);

    uint256 public constant STARTING_USER_BALANCE = 10 ether;
    uint256 public constant MIN_HEALTH_FACTOR = 1e18;
    uint256 public constant LIQUIDATION_BONUS = 10;
    uint256 public constant LIQUIDATION_THRESHOLD = 50;
    uint256 public constant LIQUIDATION_PRECISION = 100;

    uint256 amountCollateral = 10 ether;
    uint256 amountToMint = 100 ether;
    address public USER = makeAddr("user");

    // BTC
    uint256 amountWbtcDeposited = 1 * 10 ** wbtcDecimals;
    // This is the flaw! Given WBTC's 8 decimals, this WBTC is priced at $0.000003 instead of $30,000.
    //.000003000000000000
    uint256 expectedValueWbtc = 30_000 * 10 ** wbtcDecimals;
    uint256 amountDscFromWbtc =
        (expectedValueWbtc * LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;

    // WETH
    uint256 amountWethDeposited = 1 ether; // 1 WETH
    uint256 expectedValueWeth = 2_000 ether; // $2,000

    // 2_000 * 50 / 100 = 1_000 DSC
    uint256 amountDscFromWeth =
        (expectedValueWeth * LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;

    function setUp() external {
        deployer = new VulnDeployDecentralizedStableCoin();
        (dsc, dsce, helperConfig) = deployer.run();
        (
            ethUsdPriceFeed,
            btcUsdPriceFeed,
            weth,
            wbtc,
            deployerKey
        ) = helperConfig.activeNetworkConfig();
        if (block.chainid == 31337) {
            vm.deal(user, STARTING_USER_BALANCE);
        }
        ERC20DecimalsMock(weth).mint(user, STARTING_USER_BALANCE);
        ERC20DecimalsMock(wbtc).mint(user, STARTING_USER_BALANCE);
        ERC20DecimalsMock(weth).mint(exploiter, STARTING_USER_BALANCE);
        // The exploiter is not given any WBTC.

        wethDecimals = ERC20DecimalsMock(weth).decimals();
        wbtcDecimals = ERC20DecimalsMock(wbtc).decimals();
        feedDecimals = helperConfig.FEED_DECIMALS();
        //   wethDecimals:  18
        //   wbtcDecimals:  8
        //   feedDecimals:  8

        // Set initial prices.
        MockV3Aggregator(ethUsdPriceFeed).updateAnswer(
            int256(2_000 * 10 ** feedDecimals)
        ); // $2,000
        MockV3Aggregator(btcUsdPriceFeed).updateAnswer(
            int256(30_000 * 10 ** feedDecimals)
        ); // $30,000
    }

    function testExploitBTC() public {
        // A user borrows the maximum possible amount of DSC using WETH as collateral.
        // note Deposit 1 WETH to mint 1_000 DSC. HF = 1e18.
        vm.startPrank(user);
        uint256 amountWethDeposited = 1 ether; // 1 WETH
        uint256 expectedValueWeth = 2_000 ether; // $2,000

        // 2_000 * 50 / 100 = 1_000 DSC
        uint256 amountDscFromWeth = (expectedValueWeth *
            LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;

        ERC20DecimalsMock(weth).approve(address(dsce), amountWethDeposited);
        dsce.depositCollateralAndMintDSC(
            weth,
            amountWethDeposited, // 1 WETH @ $2,000
            amountDscFromWeth // 1_000 DSC
        );
        assertEq(dsc.balanceOf(user), amountDscFromWeth);
        vm.stopPrank();

        // Now the user borrows more DSC using WBTC collateral.
        // The flawed price computation ensures that the user can't borrow much at all, but they will anyway.
        vm.startPrank(user);
        uint256 amountWbtcDeposited = 1 * 10 ** wbtcDecimals; // 1 WBTC

        // This is the flaw! Given WBTC's 8 decimals, this WBTC is priced at $0.000003 instead of $30,000.
        //.000003000000000000
        uint256 expectedValueWbtc = 30_000 * 10 ** wbtcDecimals; // $0.000003 != $30,000
        console.log("expectedValueWbtc: ", expectedValueWbtc);
        //.000001500000000000
        uint256 amountDscFromWbtc = (expectedValueWbtc *
            LIQUIDATION_THRESHOLD) / LIQUIDATION_PRECISION;

        ERC20DecimalsMock(wbtc).approve(address(dsce), amountWbtcDeposited);
        dsce.depositCollateralAndMintDSC(
            wbtc,
            amountWbtcDeposited,
            amountDscFromWbtc
        );
        assertEq(dsc.balanceOf(user), amountDscFromWeth + amountDscFromWbtc);
        vm.stopPrank();
    }

    function testGetUsdValueWbtc() public {
        uint256 btcAmount = 15 * 10 ** wbtcDecimals;
        // 15 BTC * $30,000/BTC = $15,000
        uint256 expectedUsd = 450_000 * 10 ** wbtcDecimals; // in units of 1e8 not 1e18
        uint256 usdValue = dsce.getUsdValue(wbtc, btcAmount);
        // bug off by 10 decimal places
        console.log("usdValue: ", usdValue); //.0000450,000.00000000
        console.log("expectedUsd: ", expectedUsd); //450,000_000000000000000000
        assertEq(usdValue, expectedUsd);
    }

    modifier btcDepositedCollateralAndMintedDsc() {
        vm.startPrank(user);
        // approve dsce contract to use amountCollateral amount of weth
        ERC20DecimalsMock(wbtc).mint(user, STARTING_USER_BALANCE);
        ERC20DecimalsMock(wbtc).approve(address(dsce), amountWbtcDeposited);
        dsce.depositCollateralAndMintDSC(
            wbtc,
            amountWbtcDeposited,
            amountDscFromWbtc
        );
        vm.stopPrank();
        _;
    }

    modifier ethDepositedCollateralAndMintedDsc() {
        vm.startPrank(user);
        // approve dsce contract to use amountCollateral amount of weth
        ERC20DecimalsMock(weth).approve(address(dsce), amountWethDeposited);
        dsce.depositCollateralAndMintDSC(
            weth,
            amountWethDeposited, // 1 WETH @ $2,000
            amountDscFromWeth // 1_000 DSC
        );
        vm.stopPrank();
        _;
    }

    function testBtcMintDsc() public btcDepositedCollateralAndMintedDsc {
        uint actualMinted = dsce.getDSCMinted(user);
        //000000000000015000
        console.log("actualMinted: ", actualMinted);
        assertEq(amountDscFromWbtc, actualMinted);

        uint256 healthFactor = dsce.getHealthFactor(user);
        // 1e18
        console.log("healthFactor: ", healthFactor);
    }

    function testEthMintDsc() public ethDepositedCollateralAndMintedDsc {
        uint actualMinted = dsce.getDSCMinted(user);
        //1,000.000000000000000000
        console.log("actualMinted: ", actualMinted);
        assertEq(amountDscFromWeth, actualMinted);
        uint256 healthFactor = dsce.getHealthFactor(user);
        // 1e18
        console.log("healthFactor: ", healthFactor);
    }

    function testGetBtcTokenAmountFromUsd() public {
        // uint256 expectedWeth = 1 * 10 ** wbtcDecimals;
        // uint256 expectedValueWbtc = 30_000 * 10 ** wbtcDecimals;
        uint256 expectedWeth = 1 ether;
        uint256 expectedValueWbtc = 30_000 ether;
        // 2,000$ per 1 eth in mock
        uint256 actualWeth = dsce.getTokenAmountFromUsd(
            wbtc,
            expectedValueWbtc
        );
        //1.00000000
        console.log("actualWeth: ", actualWeth);
        console.log("expectedWeth: ", expectedWeth);
        assertEq(expectedWeth, actualWeth);
    }

    function testGetWbtcTokenAmountFromUsd() public {
        // If we want $10,000 of WBTC @ $1000/WBTC, that would be 10 WBTC
        uint256 expectedWbtc = 1 * 10 ** wbtcDecimals;
        uint256 amountWbtc = dsce.getTokenAmountFromUsd(wbtc, 30_000 ether);
        //1_000000000000000000
        //100000000
        assertEq(amountWbtc, expectedWbtc);
    }

    function testGetWethTokenAmountFromUsd() public {
        // If we want $10,000 of WETH @ $2000/WETH, that would be 5 WETH
        uint256 expectedWeth = 5 * 10 ** wethDecimals;
        uint256 amountWeth = dsce.getTokenAmountFromUsd(weth, 10_000 ether);
        assertEq(amountWeth, expectedWeth);
    }

    function testGetUsdValueWeth() public {
        uint256 ethAmount = 15 * 10 ** wethDecimals;
        // 15 ETH * $2000/ETH = $30,000
        uint256 expectedUsd = 30_000 ether;
        uint256 usdValue = dsce.getUsdValue(weth, ethAmount);
        assertEq(usdValue, expectedUsd);
    }

    //The return value always has the same number of decimals as the token itself, whereas it is supposed to be an 18-decimal USD amount.

    function testBTCGetUsdValueWbtc() public {
        uint256 btcAmount = 1 * 10 ** wbtcDecimals;
        // 1 BTC * $30,000/BTC = $30,000
        uint256 expectedUsd = 30_000 ether;
        uint256 usdValue = dsce.getUsdValue(wbtc, btcAmount);
        //4500_0000000000
        assertEq(usdValue, expectedUsd);
    }
}
